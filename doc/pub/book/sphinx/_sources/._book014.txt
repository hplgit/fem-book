.. !split

Finite elements in 2D and 3D
============================

Finite element approximation is particularly powerful in 2D and 3D because
the method can handle a geometrically complex domain :math:`\Omega` with ease.
The principal idea is, as in 1D, to divide the domain into cells
and use polynomials for approximating a function over a cell.
Two popular cell shapes are triangles and quadrilaterals.
It is common to denote finite elements on triangles and tetrahedrons as P while
elements defined in terms of quadrilaterals and boxes are denoted by Q.
Figures :ref:`fem:approx:fe:2D:fig:rectP1`, :ref:`fem:approx:fe:2D:fig:circP1`,
and :ref:`fem:approx:fe:2D:fig:rectQ1` provide examples. P1 elements
means linear functions (:math:`a_0 + a_1x + a_2y`) over triangles, while Q1 elements
have bilinear functions (:math:`a_0 + a_1x + a_2y + a_3xy`) over rectangular cells.
Higher-order elements can easily be defined.

.. _fem:approx:fe:2D:fig:rectP1:

.. figure:: mesh2D_rect_P1.png
   :width: 800

   *Example on 2D P1 elements*

.. _fem:approx:fe:2D:fig:circP1:

.. figure:: mesh2D_quarter_circle.png
   :width: 400

   *Example on 2D P1 elements in a deformed geometry*

.. _fem:approx:fe:2D:fig:rectQ1:

.. figure:: mesh2D_rect_Q1.png
   :width: 400

   *Example on 2D Q1 elements*

Basis functions over triangles in the physical domain
-----------------------------------------------------

Cells with triangular shape will be in main focus here.  With the P1
triangular element, :math:`u` is a linear function over each cell, as
depicted in Figure :ref:`fem:approx:fe:2D:fig:femfunc`, with
discontinuous derivatives at the cell boundaries.

.. _fem:approx:fe:2D:fig:femfunc:

.. figure:: demo2D_4x3r.png
   :width: 400

   *Example on scalar function defined in terms of piecewise linear 2D functions defined on triangles*

We give the vertices of the cells global and local numbers as in 1D.
The degrees of freedom in the P1 element are the function values at
a set of nodes, which are the three vertices.
The basis function :math:`{\varphi}_i(x,y)` is then 1 at the vertex with global vertex
number :math:`i` and zero at all other vertices.
On an element, the three degrees of freedom uniquely determine
the linear basis functions in that element, as usual.
The global
:math:`{\varphi}_i(x,y)` function is then a combination of the linear functions
(planar surfaces)
over all the neighboring cells
that have vertex number :math:`i` in common. Figure :ref:`fem:approx:fe:2D:fig:basphi`
tries to illustrate the shape of such a "pyramid"-like function.

.. _fem:approx:fe:2D:fig:basphi:

.. figure:: demo2D_basisfunc.png
   :width: 400

   *Example on a piecewise linear 2D basis function over a patch of triangles*

Element matrices and vectors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As in 1D, we split the integral over :math:`\Omega` into a sum of integrals
over cells. Also as in 1D, :math:`{\varphi}_i` overlaps :math:`{\varphi}_j`
(i.e., :math:`{\varphi}_i{\varphi}_j\neq 0`) if and only if
:math:`i` and :math:`j` are vertices in the same cell. Therefore, the integral
of :math:`{\varphi}_i{\varphi}_j` over an element is nonzero only when :math:`i` and :math:`j`
run over the vertex numbers in the element. These nonzero contributions
to the coefficient matrix are, as in 1D, collected in an element matrix.
The size of the element matrix becomes :math:`3\times 3` since there are
three degrees of freedom
that :math:`i` and :math:`j` run over. Again, as in 1D, we number the
local vertices in a cell, starting at 0, and add the entries in
the element matrix into the global system matrix, exactly as in 1D.
All details and code appear below.

Basis functions over triangles in the reference cell
----------------------------------------------------

As in 1D, we can define the basis functions and the degrees of freedom
in a reference cell and then use a mapping from the reference coordinate
system to the physical coordinate system.
We also need a mapping of local degrees of freedom numbers to global degrees
of freedom numbers.

.. (``dof_map``).

The reference cell in an :math:`(X,Y)` coordinate system has vertices
:math:`(0,0)`, :math:`(1,0)`, and :math:`(0,1)`, corresponding to local vertex numbers
0, 1, and 2, respectively. The P1 element has linear functions
:math:`{\tilde{\varphi}}_r(X,Y)` as basis functions, :math:`r=0,1,2`.
Since a linear function :math:`{\tilde{\varphi}}_r(X,Y)` in 2D is on
the form :math:`C_{r,0} + C_{r,1}X + C_{r,2}Y`, and hence has three
parameters :math:`C_{r,0}`, :math:`C_{r,1}`, and :math:`C_{r,2}`, we need three
degrees of freedom. These are in general taken as the function values at a
set of nodes. For the P1 element the set of nodes is the three vertices.
Figure :ref:`fem:approx:fe:2D:fig:P12D` displays the geometry of the
element and the location of the nodes.

.. _fem:approx:fe:2D:fig:P12D:

.. figure:: P1_2d.png
   :width: 100

   *2D P1 element*

Requiring :math:`{\tilde{\varphi}}_r=1` at node number :math:`r` and
:math:`{\tilde{\varphi}}_r=0` at the two other nodes, gives three linear equations to
determine :math:`C_{r,0}`, :math:`C_{r,1}`, and :math:`C_{r,2}`. The result is

.. _Eq:_auto63:

.. math::

    \tag{128}
    {\tilde{\varphi}}_0(X,Y) = 1 - X - Y,
        
        

.. _Eq:_auto64:

.. math::

    \tag{129}
    {\tilde{\varphi}}_1(X,Y) = X,
        
        

.. _Eq:_auto65:

.. math::

    \tag{130}
    {\tilde{\varphi}}_2(X,Y) = Y
        
        

Higher-order approximations are obtained by increasing the polynomial order,
adding additional nodes, and letting the degrees of freedom be
function values at the nodes. Figure :ref:`fem:approx:fe:2D:fig:P22D`
shows the location of the six nodes in the P2 element.

.. _fem:approx:fe:2D:fig:P22D:

.. figure:: P2_2d.png
   :width: 100

   *2D P2 element*

.. 2DO: write up local basis funcs for P2

A polynomial of degree :math:`p` in :math:`X` and :math:`Y` has :math:`n_p=(p+1)(p+2)/2` terms
and hence needs :math:`n_p` nodes. The values at the nodes constitute :math:`n_p`
degrees of freedom. The location of the nodes for
:math:`{\tilde{\varphi}}_r` up to degree 6 is displayed in Figure
:ref:`fem:approx:fe:2D:fig:P162D`.

.. _fem:approx:fe:2D:fig:P162D:

.. figure:: P1-6_2d.png
   :width: 400

   *2D P1, P2, P3, P4, P5, and P6 elements*

The generalization to 3D is straightforward: the reference element is a
`tetrahedron <http://en.wikipedia.org/wiki/Tetrahedron>`__
with vertices :math:`(0,0,0)`, :math:`(1,0,0)`, :math:`(0,1,0)`, and :math:`(0,0,1)`
in a :math:`X,Y,Z` reference coordinate system. The P1 element has its degrees
of freedom as four nodes, which are the four vertices, see Figure
:ref:`fem:approx:fe:2D:fig:P1:123D`. The P2 element adds additional
nodes along the edges of the cell, yielding a total of 10 nodes and
degrees of freedom, see
Figure :ref:`fem:approx:fe:2D:fig:P2:123D`.

.. _fem:approx:fe:2D:fig:P1:123D:

.. figure:: P1-1d2d3d.png
   :width: 400

   *P1 elements in 1D, 2D, and 3D*

.. _fem:approx:fe:2D:fig:P2:123D:

.. figure:: P2-1d2d3d.png
   :width: 400

   *P2 elements in 1D, 2D, and 3D*

.. index:: simplex elements

.. index:: simplices

.. index:: faces

.. index:: edges

The interval in 1D, the triangle in 2D, the tetrahedron in 3D, and
its generalizations to higher space dimensions are known
as *simplex* cells (the geometry) or *simplex* elements (the geometry,
basis functions, degrees of freedom, etc.). The plural forms
`simplices <http://en.wikipedia.org/wiki/Simplex>`__ and
simplexes are
also a much used shorter terms when referring to this type of cells or elements.
The side of a simplex is called a *face*, while the tetrahedron also
has *edges*.

**Acknowledgment.**
Figures :ref:`fem:approx:fe:2D:fig:P12D`-:ref:`fem:approx:fe:2D:fig:P2:123D`
are created by Anders Logg and taken from the `FEniCS book <https://launchpad.net/fenics-book>`__: *Automated Solution of Differential Equations by the Finite Element Method*, edited by A. Logg, K.-A. Mardal, and G. N. Wells, published
by `Springer <http://goo.gl/lbyVMH>`__, 2012.

Affine mapping of the reference cell
------------------------------------

Let :math:`{\tilde{\varphi}}_r^{(1)}` denote the basis functions associated
with the P1 element in 1D, 2D, or 3D, and let :math:`\boldsymbol{x}_{q(e,r)}` be
the physical coordinates of local vertex number :math:`r` in cell :math:`e`.
Furthermore,
let :math:`\boldsymbol{X}` be a point in the reference coordinate system corresponding
to the point :math:`\boldsymbol{x}` in the physical coordinate system.
The affine mapping of any :math:`\boldsymbol{X}` onto :math:`\boldsymbol{x}` is
then defined by

.. index:: affine mapping

.. _Eq:fem:approx:fe:affine:map:

.. math::

    \tag{131}
    \boldsymbol{x} = \sum_{r} {\tilde{\varphi}}_r^{(1)}(\boldsymbol{X})\boldsymbol{x}_{q(e,r)},
        
        

where :math:`r` runs over the local vertex numbers in the cell.
The affine mapping essentially stretches, translates, and rotates
the triangle. Straight or planar faces of the reference cell are
therefore mapped onto
straight or planar faces in the physical coordinate system. The mapping can
be used for both P1 and higher-order elements, but note that the
mapping itself always applies the P1 basis functions.

.. _fem:approx:fe:map:fig:2DP1:

.. figure:: ElmT3n2D_map.png
   :width: 400

   *Affine mapping of a P1 element*

[**kam 6**: Worked example here?]

Isoparametric mapping of the reference cell
-------------------------------------------

.. index:: isoparametric mapping

.. index::
   single: mapping of reference cells; isoparametric mapping

Instead of using the P1 basis functions in the mapping
:ref:`(131) <Eq:fem:approx:fe:affine:map>`,
we may use the basis functions of the actual P$d$ element:

.. _Eq:fem:approx:fe:isop:map:

.. math::

    \tag{132}
    \boldsymbol{x} = \sum_{r} {\tilde{\varphi}}_r(\boldsymbol{X})\boldsymbol{x}_{q(e,r)},
        
        

where :math:`r` runs over all nodes, i.e., all points associated with the
degrees of freedom. This is called an *isoparametric mapping*.
For P1 elements it is identical to the affine mapping
:ref:`(131) <Eq:fem:approx:fe:affine:map>`, but for higher-order elements
the mapping of the straight or planar faces of the reference cell will
result in a *curved* face in the physical coordinate system.
For example, when we use the basis functions of the triangular P2 element
in 2D in :ref:`(132) <Eq:fem:approx:fe:isop:map>`, the straight faces of the
reference triangle are mapped onto curved faces of parabolic shape in
the physical coordinate system, see Figure :ref:`fem:approx:fe:map:fig:2DP2`.

.. _fem:approx:fe:map:fig:2DP2:

.. figure:: ElmT6n2D_map.png
   :width: 400

   *Isoparametric mapping of a P2 element*

From :ref:`(131) <Eq:fem:approx:fe:affine:map>` or
:ref:`(132) <Eq:fem:approx:fe:isop:map>` it is easy to realize that the
vertices are correctly mapped. Consider a vertex with local number :math:`s`.
Then :math:`{\tilde{\varphi}}_s=1` at this vertex and zero at the others.
This means that only one term in the sum is nonzero and :math:`\boldsymbol{x}=\boldsymbol{x}_{q(e,s)}`,
which is the coordinate of this vertex in the global coordinate system.

Computing integrals
-------------------

Let :math:`\tilde\Omega^r` denote the reference cell and :math:`\Omega^{(e)}`
the cell in the physical coordinate system. The transformation of
the integral from the physical to the reference coordinate system reads

.. _Eq:_auto66:

.. math::

    \tag{133}
    \int_{\Omega^{(e)}}{\varphi}_i (\boldsymbol{x}) {\varphi}_j (\boldsymbol{x}) {\, \mathrm{d}x} =
        \int_{\tilde\Omega^r} {\tilde{\varphi}}_i (\boldsymbol{X}) {\tilde{\varphi}}_j (\boldsymbol{X})
        \det J\, {\, \mathrm{d}X},
        
        

.. _Eq:_auto67:

.. math::

    \tag{134}
    \int_{\Omega^{(e)}}{\varphi}_i (\boldsymbol{x}) f(\boldsymbol{x}) {\, \mathrm{d}x} =
        \int_{\tilde\Omega^r} {\tilde{\varphi}}_i (\boldsymbol{X}) f(\boldsymbol{x}(\boldsymbol{X})) \det J\, {\, \mathrm{d}X},
        
        

where :math:`{\, \mathrm{d}x}` means the infinitesimal area element :math:`dx dy` in 2D and
:math:`dx dy dz` in 3D, with a similar
definition of :math:`{\, \mathrm{d}X}`. The quantity :math:`\det J` is the determinant of the
Jacobian of the mapping :math:`\boldsymbol{x}(\boldsymbol{X})`. In 2D,

.. _Eq:fem:approx:fe:2D:mapping:J:detJ:

.. math::

    \tag{135}
    J = \left[\begin{array}{cc}
        \frac{\partial x}{\partial X} & \frac{\partial x}{\partial Y}\\ 
        \frac{\partial y}{\partial X} & \frac{\partial y}{\partial Y}
        \end{array}\right], \quad
        \det J = \frac{\partial x}{\partial X}\frac{\partial y}{\partial Y}
        - \frac{\partial x}{\partial Y}\frac{\partial y}{\partial X}
        {\thinspace .}
        
        

With the affine mapping
:ref:`(131) <Eq:fem:approx:fe:affine:map>`, :math:`\det J=2\Delta`, where :math:`\Delta` is
the area or volume of the cell in the physical coordinate system.

**Remark.**
Observe that finite elements in 2D and 3D builds on the same
*ideas* and *concepts* as in 1D, but there is simply much
more to compute because the
specific mathematical formulas in 2D and 3D are more complicated
and the book keeping with dof maps also gets more complicated.
The manual work is tedious, lengthy, and error-prone
so automation by the computer is a must.

.. 2DO

.. First: two triangles

.. vertices = [(0,0), (1,0), (0,1), (1,1)]

.. cells = [[0, 1, 3], [0, 3, 2]]

.. dof_map = cells

.. write up affine mapping

.. D is the area that sympy.Triangle can compute :-) No, do that directly! 0.5...

.. rhs: choose simple f=x*y, try hand-calculation or two-step

.. sympy: first integrate in y with (0,1-x) as limits, then

.. integrate the result in x

.. a = integrate(x*y*(1-x-y), (y, 0, 1-x))

.. b = integrate(a, (x,0,1))

.. use the same for local element matrix

.. show assembly

.. should have pysketcher prog for drawing 2D mesh, mark and number nodes

.. and elements

.. Should have example with x**8*(1-x)*y**8*(1-y) worked out, but

.. need software

.. Need 2D exercises

.. _fe:approx:fenics:

Implementation          (5)
===========================

.. index:: FEniCS

Our previous programs for doing 1D approximation by finite element
basis function had a focus on all the small details needed to compute
the solution. When going to 2D and 3D, the basic algorithms are the
same, but the amount of computational details with basis functions,
reference functions, mappings, numerical integration and so on,
becomes overwhelming because of all the flexibility and choices of
elements. For this purpose, we *must*, except in the simplest cases
with P1 elements, use some well-developed, existing computer
library. Here we shall use `FEniCS <http://fenicsproject.org>`__, which
is a free, open finite element package for advanced computations. The
package can be programmed in C++ or Python. How it works is best
illustrated by an example.

.. _fem:approx:fenics:2D:

Example on approximation in 2D using FEniCS
-------------------------------------------

Our previous programs for doing 1D approximation by finite element basis
function had a focus on all the
small details needed to compute the solution. When going to 2D and 3D,
the basic algorithms are the same, but the amount of computational
details with basis functions, reference functions, mappings,
numerical integration and so on, becomes overwhelming because of all
the flexibility and choices of elements. For this purpose, we *must*,
except in the simplest cases with P1 elements, use some well-developed,
existing computer library. Here we shall use
`FEniCS <http://fenicsproject.org>`__, which is a free, open finite
element package for advanced computations. The package can be programmed
in C++ or Python. How it works is best illustrated by an example.

Mathematical problem          (1)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We want to approximate the function :math:`f(x)=2xy - x^2` by P1 and P2 elements
on :math:`[0,2]\times[-1,1]` using a division into :math:`8\times 8` squares, which are
then divided into rectangles and then into triangles.

The code
~~~~~~~~

Observe that the code employs the basic concepts from 1D, but is
capable of using any element in FEniCS on any mesh in any number of
space dimensions (!).

.. code-block:: python

    from fenics import *
    
    def approx(f, V):
         """Return Galerkin approximation to f in V."""
         u = TrialFunction(V)
         v = TestFunction(V)
         a = u*v*dx
         L = f*v*dx
         u = Function(V)
         solve(a == L, u)
         return u
    
    def problem():
        f = Expression('2*x[0]*x[1] - pow(x[0], 2)', degree=2)
        mesh = RectangleMesh(Point(0,-1), Point(2,1), 8, 8)
    
        V1 = FunctionSpace(mesh, 'P', 1)
        u1 = approx(f, V1)
        u1.rename('u1', 'u1')
        u1_error = errornorm(f, u1, 'L2')
    
        V2 = FunctionSpace(mesh, 'P', 2)
        u2 = approx(f, V2)
        u2.rename('u2', 'u2')
        u2_error = errornorm(f, u2, 'L2')
    
        print 'L2 errors: e1=%g, e2=%g' % (u1_error, u2_error)
        # Simple plotting
        plot(f, title='f', mesh=mesh)
        plot(u1, title='u1')
        plot(u2, title='u2')
    
    if __name__ == '__main__':
        problem()
        interactive()  # Enable plotting

Figure :ref:`fem:approx:fenics:2D:fig1` shows the computed ``u1``. The plots of
``u2`` and ``f`` are identical and therefore not shown.
The plot itself is not very informative about the approximation quality of
P1 elements. The output
of errors becomes

.. code-block:: text

    L2 errors: e1=0.0131493, e2=4.93418e-15

.. Remember to rotate PDF file from internal FEniCS plotting:

.. pdftk dolfin_plot_1.pdf cat 1-endnorth output rotated_file.pdf

.. _fem:approx:fenics:2D:fig1:

.. figure:: fenics_2D_plot_approx.png
   :width: 400

   *Plot of the computed approximation using Lagrange elements of second order*

.. index:: TestFunction

.. index:: TrialFunction

.. index:: FunctionSpace

.. index:: solve (FEniCS function)

.. index:: project (FEniCS function)

.. index:: Expression

Dissection of the code
~~~~~~~~~~~~~~~~~~~~~~

The function ``approx`` is a general solver function for any :math:`f` and
:math:`V`.  We define the unknown :math:`u` in the variational form :math:`a=a(u,v) = \int uv{\, \mathrm{d}x}`
as a ``TrialFunction`` object and the test function :math:`v` as a
``TestFunction`` object. Then we define the variational form through
the integrand ``u*v*dx``. The linear form :math:`L` is similarly defined as
``f*v*dx``. Here, ``f`` must be an ``Expression`` object in FEniCS, i.e., a
formula defined by its implementation in C++. With ``a`` and ``L`` defined,
we re-define ``u`` to be a finite element function ``Function``, which is
now the unknown scalar field to be computed by the simple expression
``solve(a == L, u)``. We remark that the above function ``approx``
is implemented in FEniCS (in a slightly more general fashion)
in the function  ``project``.

The ``problem`` function applies ``approx`` to solve a specific problem.

Integrating SymPy and FEniCS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The definition of :math:`f` must be expressed in C++.  This part requires
two definitions: one of :math:`f` and one of :math:`\Omega`, or more precisely:
the mesh (discrete :math:`\Omega` divided into cells).  The definition of
:math:`f` is here expressed in C++ (it will be compiled for fast
evaluation), where the independent coordinates are given by a C/C++
vector ``x``. This means that :math:`x` is ``x[0]``, :math:`y` is ``x[1]``, and :math:`z` is
``x[2]``. Moreover, ``x[0]**2`` must be written as ``pow(x[0], 2)`` in
C/C++.

Fortunately, we can easily integrate SymPy and ``Expression`` objects,
because SymPy can take a formula and translate it to C/C++ code, and
then we can require a Python code to numerically evaluate the formula.
Here is how we can specify ``f`` in SymPy and use it in FEniCS as an
``Expression`` object:

.. code-block:: python

    >>> import sympy as sym
    >>> x, y = sym.symbols('x[0] x[1]')
    >>> f = 2*x*y - x**2
    >>> print f
    -x[0]**2 + 2*x[0]*x[1]
    >>> f = sym.printing.ccode(f)   # Translate to C code
    >>> print f
    -pow(x[0], 2) + 2*x[0]*x[1]
    >>> import fenics as fe
    >>> f = fe.Expression(f)

Here, the function ``ccode`` generates C code and we use
``x`` and ``y`` as placeholders for
``x[0]`` and ``x[1]``, which represent the coordinate of
a general point ``x`` in any dimension. The output of  ``ccode``
can then be used directly in  ``Expression``.

.. _fem:approx:fenics:2D:2:

Refined code with curve plotting
--------------------------------

Interpolation and projection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The operation with defining ``a``, ``L``, and solving for a ``u`` is so
common that it can be done by single FEniCS command ``project``:

.. code-block:: python

    u = project(f, V)

So, there is no need for our ``approx`` function!

If we want to do interpolation (or collocation) instead, we simply do

.. code-block:: python

    u = interpolate(f, V)

Plotting the solution along a line
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Having ``u`` and ``f`` available as finite element functions (``Function``
objects), we can easily plot the solution along a line since FEniCS
has functionality for evaluating a ``Function`` at arbitrary points
*inside the domain*. For example, here is the code for plotting :math:`u` and
:math:`f` along a line :math:`x=\hbox{const}` or :math:`y=\hbox{const}`.

.. code-block:: python

    import numpy as np
    import matplotlib.pyplot as plt
    
    def comparison_plot2D(
        u, f,           # Function expressions in x and y
        value=0.5,      # x or y equals this value
        variation='y',  # independent variable
        n=100,          # no if intervals in plot
        tol=1E-8,       # tolerance for points inside the domain
        plottitle='',   # heading in plot
        filename='tmp', # stem of filename
        ):
        """
        Plot u and f along a line in x or y dir with n intervals
        and a tolerance of tol for points inside the domain.
        """
        v = np.linspace(-1+tol, 1-tol, n+1)
        # Compute points along specified line:
        points = np.array([(value, v_)
                           if variation == 'y' else (v_, value)
                           for v_ in v])
        u_values = [u(point) for point in points] # eval. Function
        f_values = [f(point) for point in points]
        plt.figure()
        plt.plot(v, u_values, 'r-', v, f_values, 'b--')
        plt.legend(['u', 'f'], loc='upper left')
        if variation == 'y':
            plt.xlabel('y'); plt.ylabel('u, f')
        else:
            plt.xlabel('x'); plt.ylabel('u, f')
        plt.title(plottitle)
        plt.savefig(filename + '.pdf')
        plt.savefig(filename + '.png')

Integrating plotting and computations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It is now very easy to give some graphical impression of the approximations
for various kinds of 2D elements.
Basically, to solve the problem of approximating :math:`f=2xy-x^2` on :math:`\Omega = [-1,1]\times [0,2]` by P2 elements on a :math:`2\times 2` mesh,
we want to integrate the function above with following type of computations:

.. code-block:: python

    import fenics as fe
    f = fe.Expression('2*x[0]*x[1] - pow(x[0], 2)')
    mesh = fe.RectangleMesh(fe.Point(1,-1), fe.Point(2,1), 2, 2)
    V = fe.FunctionSpace(mesh, 'P', 2)
    u = fe.project(f, V)
    err = fe.errornorm(f, u, 'L2')
    print err

However, we can now easily compare different type of elements and
mesh resolutions:

.. code-block:: python

    import fenics as fe
    import sympy as sym
    x, y = sym.symbols('x[0] x[1]')
    
    def problem(f, nx=8, ny=8, degrees=[1,2]):
        """
        Plot u along x=const or y=const for Lagrange elements,
        of given degrees, on a nx times ny mesh. f is a SymPy expression.
        """
        f = sym.printing.ccode(f)
        f = fe.Expression(f)
        mesh = fe.RectangleMesh(
            fe.Point(-1, 0), fe.Point(1, 2), 2, 2)
        for degree in degrees:
            if degree == 0:
                # The P0 element is specified like this in FEniCS
                V = fe.FunctionSpace(mesh, 'DG', 0)
            else:
                # The Lagrange Pd family of elements, d=1,2,3,...
                V = fe.FunctionSpace(mesh, 'P', degree)
            u = fe.project(f, V)
            u_error = fe.errornorm(f, u, 'L2')
            print '||u-f||=%g' % u_error, degree
            comparison_plot2D(
                u, f,
                n=50,
                value=0.4, variation='x',
                plottitle='Approximation by P%d elements' % degree,
                filename='approx_fenics_by_P%d' % degree,
                tol=1E-3)
            #fe.plot(u, title='Approx by P%d' % degree)
    
    if __name__ == '__main__':
        # x and y are global SymPy variables
        f = 2*x*y - x**16
        f = 2*x*y - x**2
        problem(f, nx=2, ny=2, degrees=[0, 1, 2])
        plt.show()

(We note that this code issues a lot of warnings from the ``u(point)``
evaluations.)

We show in Figure :ref:`fem:approx:fenics:2D:2:fig1`
how :math:`f` is approximated by P0, P1, and P2 elements
on a very coarse :math:`2\times 2` mesh consisting of 8 cells.

We have also added the result obtained by P2 elements.

.. _fem:approx:fenics:2D:2:fig1:

.. figure:: approx_fenics_f1.png
   :width: 800

   *Comparison of P0, P1, and P2 approximations (left to right) along a line in a 2D mesh*


.. admonition:: Questions

   There are two striking features in the figure:
   
   1. The P2 solution is exact. Why?
   
   2. The P1 solution does not seem to be a least squares approximation. Why?




.. 1. f is of degree 2 so V covers f and therefore the P2 solution is an exact

.. of f everywhere.

.. 2. P1 solution is along a line and the curve is more over than under

.. f, but in other places it must be the other way around such that over

.. the entire domain :math:`\Omega` we have a least squares approximation!

With this code, found in the file `approx_fenics.py <$approx_fenics.py>`__,
we can easily run lots of experiments with the Lagrange element family.
Just write the
SymPy expression and choose the mesh resolution!

Exercises          (2)
======================

.. --- begin exercise ---

.. _fem:approx:fe:exer:mesh1:

Problem 11: Define nodes and elements
-------------------------------------

Consider a domain :math:`\Omega =[0,2]` divided into the three elements
:math:`[0,1]`, :math:`[1,1.2]`, and :math:`[1.2,2]`.

For P1 and P2 elements, set up the list of coordinates and nodes
(``nodes``) and the numbers of the nodes that belong to each element
(``elements``) in two cases: 1) nodes and elements numbered from left to
right, and 2) nodes and elements numbered from right to left.

.. removed !bsol ... !esol environment (because of the command-line option --without_solutions)

Filename: ``fe_numberings1``.

.. --- end exercise ---

.. --- begin exercise ---

.. _fem:approx:fe:exer:mesh2:

Problem 12: Define vertices, cells, and dof maps
------------------------------------------------

Repeat :ref:`fem:approx:fe:exer:mesh1`, but define the
data structures ``vertices``, ``cells``, and ``dof_map`` instead of
``nodes`` and ``elements``.

.. removed !bsol ... !esol environment (because of the command-line option --without_solutions)

Filename: ``fe_numberings2``.

.. --- end exercise ---

.. --- begin exercise ---

.. _fem:approx:fe:exer:defmesh:sparsity:

Problem 13: Construct matrix sparsity patterns
----------------------------------------------

:ref:`fem:approx:fe:exer:mesh1` describes a element mesh
with a total of five elements, but with two different element and
node orderings. For each of the two orderings,
make a :math:`5\times 5` matrix and fill in the entries that will be nonzero.

.. --- begin hint in exercise ---

**Hint.**
A matrix entry :math:`(i,j)` is nonzero if :math:`i` and :math:`j` are nodes in the
same element.

.. --- end hint in exercise ---

.. removed !bsol ... !esol environment (because of the command-line option --without_solutions)

Filename: ``fe_sparsity_pattern``.

.. --- end exercise ---

.. --- begin exercise ---

.. _fem:approx:fe:exer:Asinwt:symbolic:

Problem 14: Perform symbolic finite element computations
--------------------------------------------------------

Perform symbolic calculations to find formulas for the coefficient
matrix and right-hand side when approximating :math:`f(x) = \sin (x)` on
:math:`\Omega=[0, \pi]` by two P1 elements of size :math:`\pi/2`.  Solve the
system and compare :math:`u(\pi/2)` with the exact value 1.

.. removed !bsol ... !esol environment (because of the command-line option --without_solutions)

Filename: ``fe_sin_P1``.

.. Hint: wolframalpha or sympy can help with (1-x)*sin(a*x+b),

.. which is the integral

.. that arises on the right-hand side.

.. --- end exercise ---

.. --- begin exercise ---

.. _fem:approx:exer:tanh:P1P2:

Problem 15: Approximate a steep function by P1 and P2 elements
--------------------------------------------------------------

Given

.. math::
         f(x) = \tanh(s(x-\frac{1}{2}))

use the Galerkin or least squares method with finite elements to find
an approximate function :math:`u(x)`. Choose :math:`s=20` and try
:math:`N_e=4,8,16` P1 elements and
:math:`N_e=2,4,8` P2 elements.
Integrate :math:`f{\varphi}_i` numerically.

.. --- begin hint in exercise ---

**Hint.**
You can automate the computations by calling the ``approximate`` method
in the ``fe_approx1D_numint`` module.

.. --- end hint in exercise ---

.. removed !bsol ... !esol environment (because of the command-line option --without_solutions)

Filename: ``fe_tanh_P1P2``.

.. --- end exercise ---

.. --- begin exercise ---

.. _fem:approx:exer:tanh:P3P4:

Problem 16: Approximate a steep function by P3 and P4 elements
--------------------------------------------------------------

**a)**
Solve :ref:`fem:approx:exer:tanh:P1P2` using :math:`N_e=1,2,4` P3 and P4
elements.

.. removed !bsol ... !esol environment (because of the command-line option --without_solutions)

**b)**
How will an interpolation method work in
this case with the same number of nodes?

.. removed !bsol ... !esol environment (because of the command-line option --without_solutions)

Filename: ``fe_tanh_P3P4``.

.. --- end exercise ---

.. --- begin exercise ---

.. _fem:approx:fe:exer:Asinwt:interpol:error:

Exercise 17: Investigate the approximation error in finite elements
-------------------------------------------------------------------

The theory :ref:`(115) <Eq:fem:approx:fe:error:theorem>` from the section :ref:`fem:approx:fe:error` predicts that the error in the P$d$
approximation of a function should behave as :math:`h^{d+1}`, where :math:`h` is
the length of the element. Use experiments to verify this asymptotic
behavior (i.e., for small enough :math:`h`).  Choose three examples:
:math:`f(x)=Ae^{-\omega x}` on :math:`[0,3/\omega]`, :math:`f(x) = A\sin (\omega x)` on
:math:`\Omega=[0, 2\pi/\omega]` for constant :math:`A` and :math:`\omega`, and
:math:`f(x)=\sqrt{x}` on :math:`[0,1]`.

.. --- begin hint in exercise ---

**Hint 1.**
Run a series of experiments: :math:`(h_i,E_i)`, :math:`i=0,\ldots,m`, where :math:`E_i`
is the :math:`L^2` norm of the error corresponding to element length :math:`h_i`.
Assume an error model :math:`E=Ch^r` and compute :math:`r` from two successive
experiments:

.. math::
         r_i = \ln (E_{i+1}/E_i)/\ln (h_{i+1}/h_i),\quad i=0,\ldots,m-1{\thinspace .}

Hopefully, the sequence :math:`r_0,\ldots,r_{m-1}` converges to the true
:math:`r`, and :math:`r_{m-1}` can be taken as an approximation to :math:`r`.
Run such experiments for different :math:`d` for the different :math:`f(x)` functions.

.. --- end hint in exercise ---

.. --- begin hint in exercise ---

**Hint 2.**
The ``approximate`` function in ``fe_approx1D_numint.py`` is handy for
calculating the numerical solution. This function returns the
finite element solution as the coefficients :math:`\left\{ {c}_i \right\}_{i\in{\mathcal{I}_s}}`.
To compute :math:`u`, use ``u_glob`` from the same module.
Use the Trapezoidal rule to integrate the :math:`L^2` error:

.. code-block:: python

    xc, u = u_glob(c, vertices, cells, dof_map)
    e = f_func(xc) - u
    L2_error = 0
    e2 = e**2
    for i in range(len(xc)-1):
        L2_error += 0.5*(e2[i+1] + e2[i])*(xc[i+1] - xc[i])
    L2_error = np.sqrt(L2_error)

The reason for this Trapezoidal integration is
that ``u_glob`` returns coordinates ``xc`` and corresponding ``u`` values
where some of the coordinates (the cell vertices) coincides, because
the solution is computed in one element at a time, using all local
nodes. Also note that there are many coordinates in :math:`xc` per cell
such that we can accurately compute the error inside each cell.

.. --- end hint in exercise ---

.. removed !bsol ... !esol environment (because of the command-line option --without_solutions)

Filename: ``Pd_approx_error``.

.. --- end exercise ---

.. --- begin exercise ---

.. _fem:approx:fe:exer:Heaviside:

Problem 18: Approximate a step function by finite elements
----------------------------------------------------------

Approximate the step function

.. math::
         f(x) = \left\lbrace\begin{array}{ll}
        0 & \mbox{ if } 0\leq x < {1/2},\\ 
        1 & \mbox{ if } {1/2} \leq x \geq {1/2}
        \end{array}\right.
        

by 2, 4, 8, and 16 elements and  P1, P2, P3, and P4. Compare approximations visually.

.. --- begin hint in exercise ---

**Hint.**
This :math:`f` can also be expressed in terms of the Heaviside function :math:`H(x)`:
:math:`f(x) = H(x-{1/2})`.
Therefore, :math:`f` can be defined by

.. code-block:: python

    f = sym.Heaviside(x - sym.Rational(1,2))

making the ``approximate`` function in the
``fe_approx1D.py`` module an obvious candidate to solve the
problem. However, ``sympy`` does not handle symbolic integration
with this particular integrand, and the ``approximate`` function faces a problem
when converting ``f`` to a Python function (for plotting) since
``Heaviside`` is not an available function in ``numpy``.

An alternative is to perform hand calculations. This is an instructive
task, but in practice only feasible for few elements and P1 and P2 elements.
It is better to copy the functions ``element_matrix``, ``element_vector``,
``assemble``, and ``approximate`` from the ``fe_approx1D_numint.py`` file
and edit these functions such that they can compute approximations
with ``f`` given as a Python function and not a symbolic expression.
Also assume that ``phi`` computed by the ``basis`` function is a Python
callable function. Remove all instances of the ``symbolic`` variable
and associated code.

.. --- end hint in exercise ---

.. removed !bsol ... !esol environment (because of the command-line option --without_solutions)

Filename: ``fe_Heaviside_P1P2``.

.. --- end exercise ---

.. --- begin exercise ---

.. _fem:approx:fe:exer:2Dsines:symbolic:

Exercise 19: 2D approximation with orthogonal functions
-------------------------------------------------------

**a)**
Assume we have basis functions :math:`{\varphi}_i(x,y)` in 2D that are
orthogonal such that :math:`({\varphi}_i,{\varphi}_j)=0` when :math:`i\neq j`.  The
function ``least_squares`` in the file `approx2D.py <http://tinyurl.com/znpudbt/fe_approx2D.py>`__ will then spend much time on computing
off-diagonal terms in the coefficient matrix that we know are zero.
To speed up the computations, make a version ``least_squares_orth`` that
utilizes the orthogonality among the basis functions.

.. removed !bsol ... !esol environment (because of the command-line option --without_solutions)

**b)**
Apply the function to approximate

.. math::
         f(x,y) = x(1-x)y(1-y)e^{-x-y}

on :math:`\Omega = [0,1]\times [0,1]` via basis functions

.. math::
         {\varphi}_i(x,y) = \sin ((p+1)\pi x)\sin((q+1)\pi y),\quad i=q(N_x+1) + p,
        

where :math:`p=0,\ldots,N_x` and :math:`q=0,\ldots,N_y`.

.. --- begin hint in exercise ---

**Hint.**
Get ideas from the function ``least_squares_orth`` in
the section :ref:`fem:approx:global:orth` and
file `approx1D.py <http://tinyurl.com/znpudbt/fe_approx1D.py>`__.

.. --- end hint in exercise ---

.. removed !bsol ... !esol environment (because of the command-line option --without_solutions)

**c)**
Make a unit test for the ``least_squares_orth`` function.

.. removed !bsol ... !esol environment (because of the command-line option --without_solutions)

Filename: ``approx2D_ls_orth``.

.. --- end exercise ---

.. --- begin exercise ---

.. _fem:approx:fe:exer:1D:trapez:

Exercise 20: Use the Trapezoidal rule and P1 elements
-----------------------------------------------------

Consider approximation of some :math:`f(x)` on an interval :math:`\Omega` using
the least squares or Galerkin methods with P1 elements. Derive
the element matrix and vector using the
Trapezoidal rule :ref:`(123) <Eq:fem:approx:fe:numint1:trapez>` for calculating
integrals on the reference element. Assemble the contributions, assuming
a uniform cell partitioning, and show that the resulting linear system
has the form :math:`c_i=f(x_{i})` for :math:`i\in{\mathcal{I}_s}`.

.. removed !bsol ... !esol environment (because of the command-line option --without_solutions)

Filename: ``fe_P1_trapez``.

.. --- end exercise ---

.. --- begin exercise ---

.. _fem:approx:fe:exer:1D:P1:vs:interp:

Exercise 21: Compare P1 elements and interpolation
--------------------------------------------------

We shall approximate the function

.. math::
         f(x) = 1 + \epsilon\sin (2\pi nx),\quad x\in \Omega = [0,1],

where :math:`n\in\mathbb{Z}` and :math:`\epsilon \geq 0`.

**a)**
Plot :math:`f(x)` for :math:`n=1,2,3` and find the wave length of the function.

**b)**
We want to use :math:`N_P` elements per wave length. Show that the number
of elements is then :math:`nN_P`.

**c)**
The critical quantity for accuracy is the number of elements per
wave length, not the element size in itself. It therefore suffices
to study an :math:`f` with just one wave length in :math:`\Omega = [0,1]`.
Set :math:`\epsilon = 0.5`.

Run the least squares or projection/Galerkin method for
:math:`N_P=2,4,8,16,32`. Compute the error :math:`E=||u-f||_{L^2}`.

.. --- begin hint in exercise ---

**Hint 1.**
Use the ``fe_approx1D_numint`` module to compute :math:`u` and use
the technique from the section :ref:`fem:approx:fe:error` to
compute the norm of the error.

.. --- end hint in exercise ---

.. --- begin hint in exercise ---

**Hint 2.**
Read up on the Nyquistâ€“Shannon sampling theorem.

.. --- end hint in exercise ---

**d)**
Repeat the set of experiments in the above point, but
use interpolation/collocation based on the node points to
compute :math:`u(x)` (recall that :math:`c_i` is now simply :math:`f(x_{i})`).
Compute the error :math:`E=||u-f||_{L^2}`.
Which method seems to be most accurate?

Filename: ``fe_P1_vs_interp``.

.. --- end exercise ---

.. --- begin exercise ---

.. _fem:approx:fe:exer:3D:approx3D:

Exercise 22: Implement 3D computations with global basis functions
------------------------------------------------------------------

Extend the `approx2D.py <http://tinyurl.com/znpudbt/approx2D.py>`__ code to 3D
applying ideas from the section :ref:`fem:approx:3D:global`.
Construct some 3D problem to make a test function for the
implementation.

.. --- begin hint in exercise ---

**Hint.**
Drop symbolic integration since it is in general too slow for 3D problems.
Also use ``scipy.integrate.nquad`` instead of ``sympy.mpmath.quad``
for numerical integration, since it is much faster.

.. --- end hint in exercise ---

.. removed !bsol ... !esol environment (because of the command-line option --without_solutions)

Filename: ``approx3D``.

.. --- end exercise ---

.. --- begin exercise ---

.. _fem:approx:fe:exer:1D:simpson:

Exercise 23: Use Simpson's rule and P2 elements
-----------------------------------------------

Redo :ref:`fem:approx:fe:exer:1D:trapez`, but use P2
elements and Simpson's rule based on sampling the integrands at
the nodes in the reference cell.

.. removed !bsol ... !esol environment (because of the command-line option --without_solutions)

Filename: ``fe_P2_simpson``.

.. --- end exercise ---

.. --- begin exercise ---

Exercise 24: Make a 3D code for Lagrange elements of arbitrary order
--------------------------------------------------------------------

Extend the code from the section :ref:`fem:approx:fenics:2D:2` to 3D.

.. 2DO

.. Must illustrate how to make weak form of continuous problem and

.. discretize. Do that in time-dependent problems too.

.. Maybe <,> \langle, \rangle as inner product

.. Must say something about error estimates!

.. no (au')', have (\alpha u')' - it solves all the problems with a and a(.,.)

.. --- end exercise ---

